- case: typeclass_instances_union
  disable_cache: false
  main: |
    from typing import Union
    from classes import typeclass

    @typeclass
    def a(instance) -> str:
        ...

    @a.instance(str)
    @a.instance(int)
    def _a_int_str(instance: Union[str, int]) -> str:
        return str(instance)

    reveal_type(a)  # N: Revealed type is 'classes._typeclass._TypeClass[Union[builtins.str*, builtins.int*], builtins.str, def (builtins.str*) -> builtins.str, <nothing>]'


- case: typeclass_instance_mixed_order
  disable_cache: False
  main: |
    from classes import typeclass

    @typeclass
    def some(instance) -> str:
        ...

    @some.instance(int)
    def _some_str(instance: str) -> str:
        ...

    @some.instance(int)
    def _some_int(instance: str) -> str:
        ...
  out: |
    main:7: error: Argument 1 has incompatible type "Callable[[str], str]"; expected "Callable[[int], str]"
    main:11: error: Argument 1 has incompatible type "Callable[[str], str]"; expected "Callable[[int], str]"


- case: typeclass_instance_variance
  disable_cache: False
  main: |
    from classes import typeclass

    class A(object):
        ...

    class B(A):
        ...

    class C(B):
        ...

    @typeclass
    def some(instance, arg: B) -> str:
        ...

    @some.instance(str)
    def _some_str(instance: str, arg: A) -> str:
        ...

    @some.instance(bool)
    def _some_bool(instance: bool, arg: B) -> str:
        ...

    @some.instance(int)
    def _some_int(instance: int, arg: C) -> str:
        ...
  out: |
    main:20: error: Argument 1 has incompatible type "Callable[[int, C], str]"; expected "Callable[[int, B], str]"


- case: typeclass_instance_any
  disable_cache: false
  main: |
    from classes import typeclass

    @typeclass
    def a(instance):
        ...

    @a.instance(str)
    def _a_int_str(instance: str) -> str:
        return str(instance)

    reveal_type(a)  # N: Revealed type is 'classes._typeclass._TypeClass[builtins.str*, Any, def (builtins.str*) -> Any, <nothing>]'


- case: typeclass_instance_missing_first_arg
  disable_cache: false
  main: |
    from classes import typeclass

    @typeclass
    def a(instance):
        ...

    @a.instance
    def some():
        ...

  out: |
    main:7: error: Argument 1 to "instance" of "_TypeClass" has incompatible type "Callable[[], Any]"; expected "Callable[[<nothing>], Any]"


- case: typeclass_instance_wrong_param
  disable_cache: false
  main: |
    from classes import typeclass

    @typeclass
    def a(instance):
        ...

    a.instance(1)

  out: |
    main:7: error: No overload variant of "instance" of "_TypeClass" matches argument type "int"
    main:7: note:     <1 more non-matching overload not shown>
    main:7: note:     def [_InstanceType] instance(self, type_argument: Callable[[_InstanceType], Any]) -> NoReturn
    main:7: note:     def [_InstanceType] instance(self, type_argument: Type[_InstanceType], *, is_protocol: Literal[False] = ...) -> Callable[[Callable[[_InstanceType], Any]], NoReturn]
    main:7: note: Possible overload variants:


- case: typeclass_instance_annotation_only
  disable_cache: false
  main: |
    from classes import typeclass

    @typeclass
    def some(instance) -> str:
        ...

    @some.instance
    def _some_str(instance: str) -> str:
        ...

    some('abc')


- case: typeclass_instance_annotation_only_complex_types
  disable_cache: false
  main: |
    from classes import typeclass
    from typing import Union, Sized, Type, Any

    @typeclass
    def some(instance) -> str:
        ...

    @some.instance
    def _some_union(instance: Union[str, int]) -> str:
        ...

    @some.instance
    def _some_type_type(instance: Type[str]) -> str:
        ...

    @some.instance
    def _some_protocol(instance: Sized) -> str:
        ...

    @some.instance
    def _some_annotated(instance) -> str:
      ...

    @some.instance
    def _some_explicit_any(instance: Any) -> str:
      ...
  out: |
    main:8: error: Only simple instance types are allowed, got: Union[builtins.str, builtins.int]
    main:12: error: Only simple instance types are allowed, got: Type[builtins.str]
    main:16: error: Protocols must be passed with `is_protocol=True`
    main:20: error: Only simple instance types are allowed, got: Any
    main:24: error: Only simple instance types are allowed, got: Any
    main:25: error: Explicit "Any" is not allowed
